const _ = require('lodash');

const workflows_mssql = require('../mssql/workflows');
const workflows_actions = require('./wf_actions');
const tasks_mssql = require('../mssql/tasks');
const mail_processor = require('./emails');
const workflows_utils = require('./wf_utils');
const hashProvider = require('./hashes');
const error_helper = require('../helpers/error_helper');
const sql_helper = require('../mssql/mssql_helper');
const subcontractors_query_provider = require('../providers/subcontractors_query_provider');
const { sanitizeQuotesForDB } = require('../helpers/utils')
const { verbose } = require('../../logConfig')

let workflows = [];
const workflowExpiration = 10;// in minutes


const _wfGetLastSendEmailComponent = function(wf, step) {
	for(let i = step; i > 1; i--) {
		let previousComponent = wf.components[i];
		if(previousComponent && previousComponent.current_value.componentId == 1) {
			return previousComponent;
		}
	}

	return null;
}

const _wfGetLastSendEmailComponentStep = function(wf, step) {

	for(let i = step; i > 1; i--) {
		let previousComponent = wf.components[i];
		if(previousComponent && previousComponent.current_value.componentId == 1) {
			return i;
		}
	}

	return null;
}

const _getLastSentEmail = async function(hc_sc_pair, wf) {
	let lastSentEmail = null;
	let currentComp = wf.components[step - 1];
	await workflows_mssql.getLastSentEmail(hc_sc_pair, function(err, resultLastEmail) {
		if(verbose)
			console.log('Get last sent mail');
		if (err) {
			console.log(err)
		}

		lastSentEmails = resultLastEmail;
	});

	if(lastSentEmails.length > 0)	// Previous email
		lastSentEmail = lastSentEmails[0];

	return lastSentEmail;
}

const _executeRemediation = async function(step, hc_sc_pair, wf) {
	let currentComp = wf.components[step - 1];
	let remediationComponent = _getParameter(currentComp, 9);
	if(remediationComponent != null && remediationComponent != '') {
		let remediationComponentId = workflows_utils.getComponentIdByName(remediationComponent);
		switch(remediationComponentId) {
			case 4:
				await workflows_utils.wfRemediationUpdateEmailAddressTask(hc_sc_pair, step, wf);
				break;
			case 5:
				await workflows_utils.wfRemediationCalleAndUpdateEmailAddressTask(hc_sc_pair, step, wf);
				break;
			case 6:
				await workflows_utils.wfRemediationForceCalleTask(hc_sc_pair, step, wf);
				break;
		}
	}
}

const _getMessageTemplate = async function(params, hc_sc_pair) {
	let messageTemplate;
	await workflows_mssql.getTemplateByName(hc_sc_pair.hiringClientId, params.templateName, async function(err, templateResult) {
		if(verbose)
			console.log('Get WF mail template');
		if (err) {
			console.log(err)
		}

		messageTemplate = templateResult[0];
	});

	return messageTemplate;
}

const _setEmailsOptions = function(params, hc_sc_pair, messageTemplate) {
	emailOptions = {};
	emailOptions.from = params.fromEmailAddress;
	emailOptions.nameFrom = params.fromEmailName;
	emailOptions.subject = messageTemplate.subject;
	emailOptions.html = messageTemplate.bodyHTML;
	emailOptions.text = messageTemplate.bodyText;
	emailOptions.alreadyLoaded = false;
	emailOptions.createTask = true;
	emailOptions.currentUser = null;
	emailOptions.hiringClientId = hc_sc_pair.hiringClientId;
	emailOptions.subcontractorId = hc_sc_pair.subcontractorId;
	emailOptions.taskDetail = params.taskDetail;
	emailOptions.templateId = messageTemplate.id;
	emailOptions.wfGenerated = 1; // Mark this email as generated by WF
	emailOptions.templateName = messageTemplate.templateName;

	return emailOptions;
}

const _scGetContacts = async function(hc_sc_pair) {
	let contacts = [];

	await workflows_mssql.getSCContact(hc_sc_pair, function(err, result) {
		if(verbose)
			console.log('Get SC contact emails');
		if (err) {
			console.log(err)
		}
		contacts = result;

		if(verbose)
			console.log(contacts)
	});

	return contacts;
}

const _checkForWaitingTask = async function(hc_sc_pair, params, wf, step) {
	return false;
}

const _createTaskExt = async function(hc_sc_pair, wf, step, isWaitingTask, isRemediation, namep, descriptionp) {
	let currentComp = wf.components[step - 1];
	let params = {};
	let name = '';
	let description = '';
	let assignType = '';
	let assignedToUserId = null;
	let assignedToRoleId = null;
	assignedToId = '';
	let daysToComplete = '';

	let componentId = currentComp.current_value.componentId;

	if(componentId == 2) // Waiting task
	{
		name = _getParameter(currentComp, 13);
		description = _getParameter(currentComp, 14);
		assignType = _getParameter(currentComp, 11);
		assignedToId = _getParameter(currentComp, 12);
		daysToComplete = _getParameter(currentComp, 2);
	}

	if(componentId == 3) // Non Waiting task
	{
		name = _getParameter(currentComp, 18);
		description = _getParameter(currentComp, 19);
		assignType = _getParameter(currentComp, 15);
		assignedToId = _getParameter(currentComp, 16);
		daysToComplete = _getParameter(currentComp, 17);
	}

	if(componentId == 4) // Remediation - Update Email Address
	{
		name = _getParameter(currentComp, 23);
		description = _getParameter(currentComp, 24);
		assignType = _getParameter(currentComp, 20);
		assignedToId = _getParameter(currentComp, 21);
		daysToComplete = _getParameter(currentComp, 22);
	}

	if(componentId == 5) // Remediation Call & Update
	{
		name = _getParameter(currentComp, 28);
		description = _getParameter(currentComp, 29);
		assignType = _getParameter(currentComp, 25);
		assignedToId = _getParameter(currentComp, 26);
		daysToComplete = _getParameter(currentComp, 27);
	}

	if(componentId == 6) // Remediation - Force Call
	{
		name = _getParameter(currentComp, 33);
		description = _getParameter(currentComp, 34);
		assignType = _getParameter(currentComp, 30);
		assignedToId = _getParameter(currentComp, 31);
		daysToComplete = _getParameter(currentComp, 32);
	}

	if(namep != null && namep != '') {
		name = namep;
	}

	if(descriptionp != null && descriptionp != '') {
		description = descriptionp;
	}

	if(!name || !description || name == "" || description == "") {
		console.log("No name or description in component:");
		console.log(currentComp);
	}
	else {
		params.name = name;
		params.description = description;
		params.hiringClientId = hc_sc_pair.hiringClientId;
		params.userId = assignedToId;
		params.subcontractorId = hc_sc_pair.subcontractorId;
		params.dateDueDays = daysToComplete;
		params.isWaitingTask = isWaitingTask;
		params.isRemediation = isRemediation;
		params.step = step;
		params.WorkflowTypeId = wf.workflowType.id;

		if(assignType == 'Role') {
			assignedToRoleId = assignedToId;
			if(assignedToRoleId == null || assignedToRoleId == '') {
				params.assignedToRoleId = 2; // PQ Operator
			}
		}

		// If the SC status is (Pending Invitation, Invited or Pending Submission),
		// include the Subcontractor s Contact Info (Name, Email & Phone) in the Task Description
		let scName = null;
		let scPhone = '';
		let scMail = '';
		if(hc_sc_pair.subcontractorStatusId == 2 ||
			hc_sc_pair.subcontractorStatusId == 3 ||
			hc_sc_pair.subcontractorStatusId == 4) {
			// Get SC data

			const connection = await sql_helper.getConnection();
			let querySC = subcontractors_query_provider.generateSubContractorBriefQuery(hc_sc_pair.subcontractorId);
			let resultSC = await connection.request().query(querySC);
			connection.close();

			if(resultSC.recordset.length > 0) {
				const record = resultSC.recordset[0];
				scName = record.name;
				scPhone = record.phone;
				scMail = record.mail;
        console.log('scName = ', scName)
        console.log('scMail = ', scMail)
				if(scName != null) {
          let description = 'Name:' + scName + ' Phone:' + scPhone + ' Mail:' + scMail + ' - ' + params.description;
          params.description = sanitizeQuotesForDB(description)
				}
			}
		}

		console.log(params);
		await tasks_mssql.createTaskSimple(params, function(err, query) {
			if (err) {
        console.log(`
          ERROR: ${err},
          PARAMS: ${JSON.stringify(params)},
          QUERY_ID: 11,
          QUERY: ${query}
        `);
			}
		});
	}
}

const _createTask = async function(hc_sc_pair, wf, step, isWaitingTask, isRemediation) {
	await _createTaskExt(hc_sc_pair, wf, step, isWaitingTask, isRemediation, "", "");
}

exports.createTask = (hc_sc_pair, wf, step, isWaitingTask, isRemediation) => {
  _createTask(hc_sc_pair, wf, step, isWaitingTask, isRemediation)
}

const _getParameter = function(currentComp, paramId) {
	let i = 0;
	for(i = 0; i < currentComp.current_parameters.length; i++) {
		let param = currentComp.current_parameters[i];
		if(param.componentParameterId == paramId) {
			return param.value;
		}
	}
}

exports.execAction = async function(wf, hc_sc_pair) {
	const step = hc_sc_pair.wfStepIndex;
	const currentComp = wf.components[step - 1];
  const componentId = _.get(currentComp, 'current_value.componentId');

	console.log("execAction > componentId: " + componentId);

	switch (componentId) {
		case 1: // Send email
			await workflows_actions.wfSendEmail(hc_sc_pair, step, wf);
			break;

		case 2: // Add waiting task
			await workflows_actions.wfAddWaitingTask(hc_sc_pair, step, wf);
			break;

		case 3: // Add non - waiting task
			await workflows_actions.wfAddNonWaitingTask(hc_sc_pair, step,wf);
			break;

		case 4: // Remediation - Update Email Address
			await workflows_actions.wfRemediationUpdateEmailAddressTask(hc_sc_pair, step, wf);
			break;

		case 5: // Remediation Call & Update
			await workflows_actions.wfRemediationCalleAndUpdateEmailAddressTask(hc_sc_pair, step, wf);
			break;

		case 6: // Remediation - Force Call
			await workflows_actions.wfRemediationForceCalleTask(hc_sc_pair, step, wf);
			break;

		case 7: // Check behaviour
			await workflows_actions.wfCheckBehaviourTask(hc_sc_pair, step, wf);
			break;

		case 8: // Change State
			await workflows_actions.wfChangeStateTask(hc_sc_pair, step, wf);
			break;

		case 9: // Change State
			await workflows_actions.wfCheckPaymentTask(hc_sc_pair, step, wf);
			break;

		case 10: // Run process
			await workflows_actions.runProcess(hc_sc_pair, step, wf);
			break;
	}
}

exports.getWF = async function (hc_sc_pair, workflowType) {
	let workflowRes = null;
	// Chek if it is not already loaded
	let i = 0;
	for(i = 0; i < workflows.length; i++) {
		let workflow = workflows[i];
		const lifeTimeMinutes = (Date.now() - workflow.timestamp)/60000;
		if(hc_sc_pair.hiringClientId == workflow.hiringClientId &&
		 	 workflowType.id == workflow.workflowType.id &&
		 	 lifeTimeMinutes < workflowExpiration) {
				return workflow;
		}
	}

	let workflowId = null;

	// Not in memory, get it from the DB
	// Get workflow id deom hc id and wf type
	await workflows_mssql.getWorkflowId(hc_sc_pair.hiringClientId, workflowType.id, async function(err, workflowIdResult) {
		if (err) {
			console.log(err)
    }

    if (!workflowIdResult) {
      console.log(`getWF function, line 361 in wf_utils.js, returned null b/c workflowIdResult is undefined in Database.  Args-> hc_sc_pair.hiringClientId: ${hc_sc_pair.hiringClientId}, workflowType.id: ${workflowType.id} `)
      return
    }

		workflowId = workflowIdResult;
	});

	if(verbose)
		console.log('Workflow process > get wf id by hc id and wf type:' + workflowId);

	let components = [];
	let componentsResp = [];

	if(workflowId && workflowId != null) {
		await workflows_mssql.getWorkflowComponents(workflowId, async function(err, wfResult) {

			if (err) {
				console.log(err)
			}

			components = wfResult.recordset;
		});

		for(i = 0; i < components.length; i++) {
			var component = {};
			component.positionIndex =components[i].positionIndex;
			component.current_value = {};
			component.current_value.componentId = components[i].componentId;
			component.current_value.workflowComponentId = components[i].workflowComponentId;
			component.current_value.name = components[i].name;

			// Get parameters
			let current_parameters = [];
			await workflows_mssql.getComponentCurrentParameters(components[i].workflowComponentId, function(err, parametersResult) {
					if (err) {
						console.log(err);
						let error = error_helper.getSqlErrorData(err);
						throw new Error(error);
					}

					var parameters = parametersResult.recordset;
					for(j = 0; j < parameters.length; j++) {
						var current_parameter = {};
						current_parameter.workflowsComponentsParamsValuesId = parameters[j].workflowsComponentsParamsValuesId;
						current_parameter.componentParameterId = parameters[j].componentParameterId;
						current_parameter.name = parameters[j].name;
						current_parameter.value = parameters[j].value;
						current_parameter.componentId = parameters[j].componentId;
						current_parameters.push(current_parameter);
					}
				});

				component.current_parameters = current_parameters;
				componentsResp.push(component);
			}

	}

	// create the new wf to cache
	let workflow = {};
	workflow.hiringClientId = hc_sc_pair.hiringClientId;
	workflow.workflowType = workflowType;
	workflow.components = componentsResp;
	workflow.timestamp = Date.now();

	// remove cached wf if already in array (expired timestamp)
	const idx = _.findIndex(workflows, function(wf) {
		return (wf.hiringClientId == workflow.hiringClientId &&
			wf.workflowType.id == workflow.workflowType.id);
	});
	if(idx != -1){
		workflows.splice(idx, 1);
	}

	// add new wf
	workflows.push(workflow);
	return workflow;
}

exports.getStatusIdByName = async function(statusName) {
	let statusList = [];
	statusList = await workflows_mssql.getSCStatusPossibleValues();
	for(let i = 0; i < statusList.length; i++) {
		if(statusList[i].value == statusName) {
			return statusList[i].id;
		}
	}
	return 0;
}

exports.getComponentIdByName = async function(componentName) {
	let componentsList = [];
	componentsList = await workflows_mssql.getWFComponentsPossibleValues();
	for(let i = 0; i < componentsList.length; i++) {
		if(componentsList[i].value == componentName) {
			return componentsList[i].id;
		}
	}
	return 0;
}

exports.checkInvite = async function(hc_sc_pair, params, wf, step) {

	// Get last email status for the hc / sc provided
	let done = false;
	let lastSentEmails;

	let lastSentEmail = await _getLastSentEmail(hc_sc_pair, wf);

	let needToResend = false;
	if(lastSentEmail == null) {
		needToResend = false
	}
	else {
		if(lastSentEmail.bounceCode != null || lastSentEmail.droppedCode != null) {
			// Email was bounced or dropped
			needToResend = true;
		}
	}

	if(needToResend == false) {
		// Failed test > Need to resend
		let currentIteration = hc_sc_pair.wfIterationCount;

		if(needToResend && currentIteration < params.numberOfIterations) {
			// Chek if there is a previous step in the current workflow type
			if(step <= 1) {
				console.log("No previous step in the current workflow type");
				return;
			}

			// Get previous sned email step
			let previousSendEmailComponent =  _wfGetLastSendEmailComponent(wf, step);
			let previousSendEmailComponentStep =  _wfGetLastSendEmailComponentStep(wf, step);

			if(previousSendEmailComponent != null) {
				_wfSendEmail(hc_sc_pair, previousSendEmailComponentStep - 1, wf);
			}
			currentIteration++;
			hc_sc_pair.wfIterationCount++;
			await workflows_mssql.setWfIteration(hc_sc_pair, currentIteration, function(err) {
					if (err) {
						console.log(err);
					}
			});
		}

		// Passed test > Done
		if(!needToResend) {
			done = true;
		}
	}
	else {
		done = true;
	}

	return done;
}

exports.incrementIteration = async function(hc_sc_pair) {
	let currentIteration = hc_sc_pair.wfIterationCount;
	// Increment current interation
	currentIteration++;

	await workflows_mssql.setWfIteration(hc_sc_pair, currentIteration, function(err) {
		if (err) {
			console.log(err);
		}
	});
}

exports.setMustPayFlag = async function(hc_sc_pair, mustPay) {
	await workflows_mssql.setMustPayFlag(hc_sc_pair, mustPay, function(err) {
		if (err) {
			console.log(err);
		}
	});
}


exports.incrementStep = async function(hc_sc_pair, step, wf) {
	step++;

	await workflows_mssql.setWfStep(hc_sc_pair, step, function(err) {
		if (err) {
			console.log(err);
		}
	});
}

exports.resetStep = async function(hc_sc_pair) {

	await workflows_mssql.setWfStep(hc_sc_pair, 1, function(err) {
		if (err) {
			console.log(err);
		}
	});
}

exports.getParameter = function(currentComp, paramId) {
	return _getParameter(currentComp, paramId);
}

exports.wfGetLastWaitingTask = async function(hc_sc_pair, step, wf) {
	let lastTask = null;
	await tasks_mssql.getLastWFWaitingTask(hc_sc_pair, step, wf, function(err, lastTaskResult) {
		if (err) {
			console.log(err);
		}

		lastTask = lastTaskResult;
	});
	return lastTask;
}

exports.wfGetLastWaitingTaskByStatusId = async function(hc_sc_pair, statusId) {
	await workflows_mssql.setWfSCStatusById(hc_sc_pair, statusId, function(err) {
		if (err) {
			let error = error_helper.getSqlErrorData(err);
			console.log(err);
			callback(err);
		}
	});
}

exports.wfSendEmail = async function(hc_sc_pair, step, wf) {
	if(verbose) {
		console.log("_wfSendEmail:");
		console.log(hc_sc_pair);
		console.log(step);
		console.log(wf.components[step - 1]);
	}

	let currentComp = wf.components[step - 1];
	let params = {};
	params.fromEmailAddress = _getParameter(currentComp, 3);
	params.fromEmailName = _getParameter(currentComp, 4);
	params.templateName = _getParameter(currentComp, 1);
	params.remediationComponent = _getParameter(currentComp, 9);
	params.status = _getParameter(currentComp, 10);
	params.statusUpdateFlag = _getParameter(currentComp, 5);

	if(!params.fromEmailAddress || params.fromEmailAddress == "") {
		console.log("No email address in component:");
		console.log(currentComp);
	}
	else {
		// Get template
		let messageTemplate = await _getMessageTemplate(params, hc_sc_pair);
		// Check it a template was found, if not log an error and do nothing
		if(messageTemplate == null) {
			console.log('No template was found for provided parameter: ' + params.templateName);
			return;
		}

		// Prepare email parameters
		let emailOptions = _setEmailsOptions(params, hc_sc_pair, messageTemplate);

		await mail_processor.getAllTemplateFields(emailOptions.hiringClientId, emailOptions.subcontractorId, null, null, function (err, data) {
			try {
				if (err) {
					error = error_helper.getSqlErrorData(err);
					console.log(err);
					callback(err);
				}

				console.log(data);

				Object.assign(emailOptions, data);
			}
			catch(err) {
				console.log("Message Template replacement error:");
				console.log(err);
				console.log(emailOptions);
			}
		});

		// Get contacts
		let contacts = await _scGetContacts(hc_sc_pair);

		if(verbose) console.log(contacts);

		// invite hash
		console.log("invite hash");
		let tokenParams = {};
		tokenParams.hiringClientId = hc_sc_pair.hiringClientId;
		tokenParams.subcontractorId = hc_sc_pair.subcontractorId;
		let hash = await hashProvider.createToken(tokenParams);
		console.log(emailOptions.url_registration);
		emailOptions.url_registration += '/register/' + hash;
		console.log(emailOptions.url_registration);


		// Send emails to all contacts
		for(let i = 0; i < contacts.length; i++) {
			mailTo = contacts[i].mail; // Where should we get this from? Last email? Current contact in DB?
			nameTo = contacts[i].fullName;

			//Set new options to email
			emailOptions.to = mailTo;
			emailOptions.name = nameTo;

			emailOptions.hiring_client_mail = mailTo;
			emailOptions.hiring_client_full_name = nameTo;

			emailOptions.subcontractor_mail = mailTo;
			emailOptions.subcontractor_full_name = nameTo;

			emailOptions.user_mail = mailTo;
			emailOptions.user_full_name = nameTo;

			if(verbose) console.log(emailOptions);

			await mail_processor.sendEmailSimple(emailOptions, function(err) {
				if (err) {
					let error = error_helper.getSqlErrorData(err);
					console.log(err);
					callback(err);
				}
			});
		}

		// Change status if required
		if(params.statusUpdateFlag == 'True') {
			if(verbose) console.log("Change status to: " + params.status);

			await workflows_mssql.setWfSCStatusByName(hc_sc_pair, params.status, function(err) {
				if (err) {
					let error = error_helper.getSqlErrorData(err);
					console.log(err);
					callback(err);
				}
			});
		}
	}
}

exports.wfAddWaitingTask = async function(hc_sc_pair, step, wf) {
	let lastTask = await exports.wfGetLastWaitingTask(hc_sc_pair, step, wf);
 	if(verbose)
 		console.log(lastTask);

	if(lastTask != null) {
		if(verbose)
			console.log("Task Exists");
		// Task already exists, check if it is completed
		if(lastTask.completedDate == null) {
			if(verbose)
				console.log("Task not complete");

			// Task is not complete
			// then do nothing and wait
			return
		}
		else {
			// Task is completed, increment step
			// increment step
			if(verbose)
				console.log("Task complete, increment step");

			await workflows_utils.incrementStep(hc_sc_pair, step, wf);
			return;
		}
	}
	else {
		// Task needs to be created
		// Create task
		if(verbose)
			console.log("Task doesn't exists, create it");

		await _createTask(hc_sc_pair, wf, step, 1, 0);
		return;
	}
}

exports.wfRemediationUpdateEmailAddressTask = async function(hc_sc_pair, step, wf) {
	let name = "Update Bounced Email Address";
	let description = "Update Bounced Email Address";
	await _createTaskExt(hc_sc_pair, wf, step, 1, 1, name, description);
}

exports.wfRemediationCalleAndUpdateEmailAddressTask = async function(hc_sc_pair, step, wf) {
	let name = "Call and Update Bounced Email Address";
	let description = "Call and Update Bounced Email Address";
	await _createTaskExt(hc_sc_pair, wf, step, 1, 1, name, description);
}

exports.wfRemediationForceCalleTask = async function(hc_sc_pair, step, wf) {
	let name = "Force Call";
	let description = "Force Call";
	await _createTaskExt(hc_sc_pair, wf, step, 1, 1, name, description);
}

exports.wfGetLastSendEmailComponent = function(wf, step) {
	return _wfGetLastSendEmailComponent(wf, step);
}